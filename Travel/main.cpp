#include <iostream>
#include <vector>
#include <cmath>
#include <utility>
#include <set>
#include<queue>
using namespace std;
/*
 Однажды группа спелеологов отправилась покорять африканские пещеры. Углубившись достаточно далеко, они обнаружили что-то странное - пахло дымом. "Неужели мы подобрались к вулкану?" - удивленно спросил новичок. "Нет. Около вулкана пахнет серой", - ответил капитан. "Кто у нас занимался тушением костров?". Все неуверенно пожали плечами. "Итак, друзья, мы в ловушке".

Перед капитаном команды спелеологов возникла непосильная задача: как же вывести свою группу из пещеры, не сгорев? Пещера в терминах спелеологов состоит из множества "тоннелей" и "станций". Каждый тоннель соединяет какую-нибудь пару различных станций и имеет свою длину. У капитана имеется карта пещеры, и он знает, где они разводили костры, и где находится выход из пещеры.

Каждую секунду дым распространяется на 1 метр. Таким образом, тоннель длины "k", смежный с уже задымленной станцией, заполнится дымом за "k" секунд, а также заполнится дымом и соответствующая станция. Если спелеологи находятся на станции, где есть дым, они задыхаются. Спелеологи бегут со скоростью 1 метр в секунду. Изначально дым есть только в тех станциях, где спелеологи разводили костры.

Перемещаться по тоннелям можно в обе стороны. Если спелеологи прибывают на станцию одновременно с дымом, то они задыхаются (это верно и для той станции, где расположен выход). Гарантируется, что сейчас спелеологи находятся на станции, где нет дыма.
Формат входных данных
В первой строке входных данных содержится три целых числа N, M и K - количество станций, тоннелей и станций с кострами соответственно (2 ≤ N ≤ 2*105, 0 ≤ M ≤ 2*105, 1 ≤ K < N).

Во второй строке содержится K различных чисел ai - номера станций, в которых спелеологи разводили костры (1 ≤ ai ≤ N).

Следующие M строк описывают тоннели. Каждое описание состоит из трех чисел xi, yi и li, обозначающих номера станций, которые соединяет i-ый тоннель, и его длину в метрах (1 ≤ xi, yi ≤ N, 1 ≤ li ≤ 109$, xi != yi). В последней строке входных данных содержится 2 числа S и F - номер станции, на которой сейчас находятся спелеологи и номер станции, в которой находится выход из пещеры (1 ≤ S, F ≤ N).
Формат результата
Выведите единственное число - минимальное количество секунд, которое требуется спелеологам для того, чтобы выбраться из пещеры, либо "-1", если спелеологам не удастся выбраться.
 Входные данные:
6 5 1
6
1 2 20
2 3 2
3 4 1
2 5 1
5 6 3
4 1
 Результат работы:
23
 Входные данные:
6 6 2
4 1
4 1 1
6 5 1
2 4 1
1 5 2
5 6 2
5 1 2
3 6
 Результат работы:
-1
 */
struct Edge {
    int start, finish, w;
    Edge(int start, int finish, int w) : start(start), finish(finish), w(w)
    {}
};
struct Graph {
    int size = 0;
    vector<vector<Edge>> edges;
    Graph(int size) : size(size), edges(size) {}

    void addNewEdge(int start, int finish, int w) {
        edges[start].emplace_back(Edge(start, finish, w));
    }
    const vector<Edge> &getEdges(int from) {
        return edges[from];
    }
};


long long  AlgorithmDijkstra(Graph &G, vector<int> start_vertex, int v) {
    vector<long long> d(G.size, 1e18);
    vector<bool> used(G.size, false);
    priority_queue<pair<long long, int>> MIN;
    for (auto i : start_vertex) {
        d[i] = 0;
        MIN.push(make_pair(0, i));
    }
    while (!MIN.empty()) {
        int min_d = MIN.top().second;
        MIN.pop();
        for (auto &edge : G.edges[min_d]) {
            if (d[edge.finish] > d[min_d] + edge.w) {
                d[edge.finish] = d[min_d] + edge.w;
                MIN.push({-d[edge.finish], edge.finish});
            }
        }
    }
    return d[v];
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);
    int N, M, K;
    cin >> N >> M >> K;
    vector<int> start_vertex(K);
    for(auto &i : start_vertex){
        cin>>i;
        --i;
    }
    Graph G(N);
    while (M--) {
        int t_1, t_2, w;
        cin >> t_1 >> t_2 >> w;
        G.addNewEdge(t_2 - 1, t_1 - 1, w);
        G.addNewEdge(t_1 - 1, t_2 - 1, w);

    }
    int S, F;
    cin >> S >> F;

    long long t = AlgorithmDijkstra(G, {--S}, --F);
    if (t < AlgorithmDijkstra(G, start_vertex, F)) {
        cout << t;
    }
    else {
        cout << -1;
    }
