#include <iostream>
#include <vector>
#include<algorithm>
#include<stack>
using namespace std;
/*
 Программисту Васе не повезло — вместо отпуска его послали в командировку, на научную конференцию. Надо повышать уровень знаний, сказал начальник, важная конференция по криптографии, проводится во Франции — а там шифровали еще во времена Ришелье и взламывали чужие шифры еще во времена Виета.

Вася быстро выяснил, что все луврские картины он уже где-то видел, вид эйфелевой башни приелся ему еще раньше, чем мышка стерла его с коврика, а такие стеклянные пирамиды у нас делают надо всякими киосками и сомнительными забегаловками. Одним словом, смотреть в Париже оказалось просто не на что, рыбу половить негде, поэтому Васе пришлось посещать доклады на конференции.

Один из докладчиков, в очередной раз пытаясь разгадать шифры Бэкона, выдвинул гипотезу, что ключ к тайнам Бэкона можно подобрать, проанализировав все возможные подстроки произведений Бэкона.

«Но их же слишком много!» — вслух удивился Вася.

«Нет, не так уж и много!» — закричал докладчик — «подсчитайте и вы сами убедитесь!».

Тем же вечером Вася нашел в интернете полное собрание сочинений Бэкона. Он написал программу, которая переработала тексты в одну длинную строку, выкинув из текстов все пробелы и знаки препинания. И вот теперь Вася весьма озадачен — а как же подсчитать количество различных подстрок этой строки?
Формат входных данных
На входе дана непустая строка, полученная Васей. Строка состоит только из строчных латинских символов. Ее длина не превосходит 5000 символов.
Формат результата
Выведите количество различных подстрок этой строки.
 Входные данные:
 aaba
 результат работы:
 8
 */

int prefFun(string str) {
    reverse(str.begin(), str.end());
    vector<int> pref(str.size());
    pref[0] = 0;
    int max_pref = 0;
    for (int i = 1; i < str.size(); ++i) {
        int tmp = pref[i - 1];
        while (tmp > 0 && str[tmp] != str[i]) {
            tmp = pref[tmp - 1];
        }
        pref[i] = (str[i] == str[tmp] ? tmp + 1 : 0);
        max_pref = std::max(max_pref, pref[i]);
    }
    return max_pref;
}

int main() {
    string str, tmp_str = "";
    cin >> str;
    int res = 0;
    for (auto c : str) {
        tmp_str += c;
        res += tmp_str.length() - prefFun(tmp_str);
    }
    cout << res;


}