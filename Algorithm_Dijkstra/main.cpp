#include<iostream>
#include<vector>
#include<set>
using namespace std;
/*
 Напишите программу, которая будет находить расстояния в неориентированном взвешенном графе с неотрицательными длинами ребер, от указанной вершины до всех остальных. Программа должна работать быстро для больших разреженных графов.
 Формат входных данных
 В первой строке входных данных задано число NUM — количество различных запусков алгоритма Дейкстры (на разных графах). Далее следуют NUM блоков, каждый из которых имеет следующую структуру.
 
 Первая строка блока содержит два числа N и M, разделенные пробелом — количество вершин и количество ребер графа. Далее следуют M строк, каждая из которых содержит по три целых числа, разделенные пробелами. Первые два из них в пределах от 0 до N–1 каждое и обозначают концы соответствующего ребра, третье — в пределах от 0 до 20000 и обозначает длину этого ребра. Далее, в последней строке блока, записанное единственное число от 0 до N–1 — вершина, расстояния от которой надо искать.
 
 Количество различных графов в одном тесте NUM не превышает 5. Количество вершин не превышает 60000, рёбер — 200000.
 Формат результата
 Выведите на стандартный выход (экран) NUM строк, в каждой из которых по N_i чисел, разделенных пробелами — расстояния от указанной начальной вершины взвешенного неориентированного графа до его 0-й, 1-й, 2-й и т. д. вершин (допускается лишний пробел после последнего числа). Если некоторая вершина недостижима от указанной начальной, вместо расстояния выводите число 2009000999 (гарантировано, что все реальные расстояния меньше).
 Входные данные:
 1
 5 7
 1 2 5
 1 3 2
 2 3 4
 2 4 3
 3 4 6
 0 3 20
 0 4 10
 1
 Результат работы:
 18 0 5 2 8
 */
vector<int> d;
vector<bool> used;
int MAX = 2009000999;
void Initialize(int s, vector<vector<pair<int, int> > > &G){
    int n = G.size();
    d.assign(n, MAX);
    d[s] = 0;
    used.assign(n, false);
}

void Dijkstra(int s, vector<vector<pair<int, int> > > &G){
    Initialize(s, G);
    int n = G.size();
    set<pair<int, int> > q;
    for(int i = 0; i < n; ++i){
        q.insert(make_pair(d[i], i));
    }

    for(int i = 0; i < n; ++i){
        pair<int, int> temp = *(q.begin());
        q.erase(q.begin());
        int u = temp.second;
        used[u] = true;
        for(int j = 0; j < G[u].size(); ++j){
            int to = G[u][j].first;
            if(!used[to]){
                q.erase(make_pair(d[to], to));
                d[to] = min(d[to], d[u] + G[u][j].second);
                q.insert(make_pair(d[to], to));
            }
        }
    }
}
int main() {
    int cmd;
    cin >> cmd;
    for (int i = 0; i < cmd; ++i) {
        int n, m;
        cin >> n >> m;
        vector<vector<pair<int, int> > > G(n);
        for (int j = 0; j < m; ++j) {
            int l, r, w;
            cin >> l >> r >> w;
            G[l].push_back(make_pair(r, w));
            G[r].push_back(make_pair(l, w));
        }
        int s;
        cin >> s;

        Dijkstra(s, G);
        for (auto distance : d)
            cout << distance << " ";
        cout << endl;

    }
}
