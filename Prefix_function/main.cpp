#include <iostream>
#include <vector>
using namespace std;

/*
 Дана непустая строка S, длина которой N не превышает 10^6. Будем считать, что элементы строки нумеруются от 1 до N.

Для каждой позиции i символа в строке нас будет интересовать подстрока, заканчивающаяся в этой позиции, и совпадающая с некоторым началом всей строки. Вообще говоря, таких подстрок будет несколько, не меньше двух. Самая длинная из них имеет длину i, она нас интересовать не будет. А будет нас интересовать самая длинная из остальных таких подстрок (заметим, что такая подстрока всегда существует — в крайнем случае, если ничего больше не найдется, сгодится пустая подстрока).

Значением префикс-функции π[i] будем считать длину этой подстроки.

Префикс-функция используется в различных алгоритмах обработки строк. В частности, с её помощью можно быстро решать задачу о поиске вхождения одной строки в другую («поиск образца в тексте»).

Требуется для всех i от 1 до N вычислить π[i].
Формат входных данных
Одна строка длины N, 1 ≤ N ≤ 10^6, состоящая из маленьких латинских букв.
Формат результата
Выведите N чисел — значения префикс-функции для каждой позиции, разделенные пробелом.
 Входные данные:
abracadabra
 Результат работы:
0 0 0 1 0 1 0 1 2 3 4
 */
vector<int> prefFun(string &str) {
    vector<int> pref(str.size());
    pref[0] = 0;
    for (int i = 1; i < str.size(); ++i) {
        int tmp = pref[i - 1];
        while (tmp > 0 && str[tmp] != str[i]) {
            tmp = pref[tmp - 1];
        }
        pref[i] = str[i] == str[tmp] ? tmp + 1 : 0;
    }

    return pref;
}

int main() {
    string str;
    cin >> str;
    vector<int> res = prefFun(str);
    for(auto u : res) {
        cout << u << ' ';
    }
    return 0;
}